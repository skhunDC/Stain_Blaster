<!doctype html>
<!-- Kiosk build: audio & restricted APIs removed -->
<html lang="en" class="h-full">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Stain Blaster – Dublin Cleaners</title>
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
      .stain {
        position: absolute;
        filter: drop-shadow(2px 2px 3px rgba(0, 0, 0, 0.4));
        z-index: 10;
      }
      .glitch-cannon {
        position: fixed;
        width: 220px;
        height: auto;
        pointer-events: none;
        z-index: 50;
        transform-origin: 18% 64%;
        transform: rotate(calc(180deg + var(--cannon-rotation, 0deg)));
      }
      .glitch-cannon--top-left {
        top: calc(env(safe-area-inset-top, 0px) + 1rem);
        left: calc(env(safe-area-inset-left, 0px) + 1rem);
        right: auto;
        bottom: auto;
      }

      .glitch-cannon--bottom-right {
        bottom: calc(env(safe-area-inset-bottom, 0px) + 1rem);
        right: calc(env(safe-area-inset-right, 0px) + 1rem);
        top: auto;
        left: auto;
      }

      .glitch-cannon--bottom-left {
        bottom: calc(env(safe-area-inset-bottom, 0px) + 1rem);
        left: calc(env(safe-area-inset-left, 0px) + 1rem);
        top: auto;
        right: auto;
      }
      .glitch-shell {
        position: relative;
        display: inline-block;
        transform-origin: center;
      }
      .glitch-shell .glitch-main {
        display: block;
        width: 100%;
        height: auto;
      }
      .glitch-shell .glitch-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        pointer-events: none;
        mix-blend-mode: screen;
      }
      .glitch-shell .glitch-layer--red {
        filter: hue-rotate(-45deg) saturate(260%) brightness(1.2);
      }
      .glitch-shell .glitch-layer--cyan {
        filter: hue-rotate(160deg) saturate(240%) brightness(1.2);
      }
      #logo .glitch-main {
        filter: drop-shadow(0 18px 38px rgba(16, 185, 129, 0.35));
      }

      #highScoreModal {
        touch-action: none;
      }

      #highScoreModal .kb-row {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        justify-content: center;
      }

      #highScoreModal .kb-key {
        min-width: 72px;
        padding: 1rem 1.2rem;
        font-size: 1.75rem;
        font-weight: 800;
        border-radius: 1.1rem;
        background: linear-gradient(145deg, #d1fae5, #6ee7b7);
        color: #064e3b;
        border: none;
        box-shadow: 0 18px 32px rgba(16, 185, 129, 0.35);
        transition: transform 0.1s ease, box-shadow 0.1s ease;
      }

      #highScoreModal .kb-key:active {
        transform: scale(0.94);
        box-shadow: 0 8px 16px rgba(16, 185, 129, 0.45);
      }

      #highScoreModal .kb-key--wide {
        min-width: 120px;
      }

      #highScoreModal .kb-key--xl {
        min-width: 200px;
      }

      #highScoreModal .kb-key--action {
        background: linear-gradient(145deg, #34d399, #047857);
        color: #ecfdf5;
      }

      #highScoreModal .kb-key--secondary {
        background: linear-gradient(145deg, #fde68a, #f59e0b);
        color: #78350f;
      }

      .bubble {
        position: absolute;
        pointer-events: none;
        filter: drop-shadow(0 20px 32px rgba(16, 185, 129, 0.35));
        transform-origin: center;
        text-shadow: 0 2px 6px rgba(16, 185, 129, 0.35);
      }
      .bubble::before {
        content: "";
        position: absolute;
        bottom: -14px;
        left: 50%;
        transform: translateX(-50%);
        border-width: 14px 14px 0 14px;
        border-style: solid;
        border-color: #10b981 transparent transparent transparent;
      }
      .bubble::after {
        content: "";
        position: absolute;
        bottom: -11px;
        left: 50%;
        transform: translateX(-50%);
        border-width: 11px 11px 0 11px;
        border-style: solid;
        border-color: rgba(255, 255, 255, 0.95) transparent transparent
          transparent;
      }
      .bubble-wow {
        position: relative;
        width: clamp(220px, 60vw, 420px);
        aspect-ratio: 1;
        display: grid;
        place-items: center;
        isolation: isolate;
        animation: bubble-sway 7s ease-in-out infinite;
        cursor: pointer;
      }
      .bubble-wow::before {
        content: "";
        position: absolute;
        inset: 8%;
        border-radius: 999px;
        background: radial-gradient(
          circle at 28% 28%,
          rgba(255, 255, 255, 0.95) 0%,
          rgba(240, 253, 250, 0.55) 28%,
          rgba(110, 231, 183, 0.28) 56%,
          rgba(16, 185, 129, 0.18) 74%,
          rgba(16, 185, 129, 0) 100%
        );
        filter: blur(0.5px);
        opacity: 0.8;
        mix-blend-mode: screen;
        z-index: 0;
        animation: bubble-halo 6s ease-in-out infinite;
      }
      .bubble-wow::after {
        content: "";
        position: absolute;
        inset: 3%;
        border-radius: 999px;
        border: 2px solid rgba(209, 250, 229, 0.65);
        mix-blend-mode: screen;
        filter: blur(0.2px);
        opacity: 0.85;
        z-index: 1;
        animation: bubble-halo 5s ease-in-out infinite reverse;
      }
      .bubble-wow__image {
        width: 100%;
        height: 100%;
        object-fit: contain;
        pointer-events: none;
        filter: drop-shadow(0 32px 45px rgba(16, 185, 129, 0.35));
        z-index: 2;
        animation: bubble-breathe 5.5s ease-in-out infinite;
      }
      .bubble-wow__sparkle {
        position: absolute;
        width: 24%;
        aspect-ratio: 1;
        border-radius: 50%;
        background: radial-gradient(
          circle,
          rgba(255, 255, 255, 0.95),
          rgba(255, 255, 255, 0)
        );
        opacity: 0.75;
        mix-blend-mode: screen;
        filter: blur(0.4px);
        z-index: 2;
        animation: bubble-twinkle 4s ease-in-out infinite;
      }
      .bubble-wow__sparkle--one {
        top: 14%;
        left: 18%;
        animation-delay: -0.4s;
      }
      .bubble-wow__sparkle--two {
        top: 24%;
        right: 16%;
        animation-delay: 0.9s;
      }
      .bubble-wow__sparkle--three {
        bottom: 18%;
        left: 24%;
        animation-delay: 1.8s;
      }
      .bubble-wow__button {
        position: relative;
        z-index: 3;
        border-radius: 999px;
        border: none;
        background: linear-gradient(135deg, #34d399, #0f766e);
        color: #f0fdfa;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        font-weight: 800;
        box-shadow: 0 18px 32px rgba(16, 185, 129, 0.45);
        transition: transform 0.15s ease, box-shadow 0.15s ease;
        animation: bubble-button-pop 3.8s ease-in-out infinite;
      }
      .bubble-wow__button:hover,
      .bubble-wow__button:focus-visible {
        transform: scale(1.05);
        box-shadow: 0 22px 36px rgba(14, 116, 144, 0.45);
      }
      .bubble-wow__button:active {
        transform: scale(0.94);
        box-shadow: 0 12px 22px rgba(16, 185, 129, 0.55);
      }
      .bubble-wow__caption {
        text-transform: uppercase;
        letter-spacing: 0.24em;
      }
      @keyframes bubble-in {
        0% {
          transform: scale(0.45);
          opacity: 0;
        }
        55% {
          transform: scale(1.18);
        }
        75% {
          transform: scale(0.96);
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      @keyframes bubble-out {
        to {
          transform: scale(0.8);
          opacity: 0;
        }
      }

      @keyframes bubble-glow {
        0%,
        100% {
          transform: translateY(0) scale(1);
          filter: drop-shadow(0 20px 32px rgba(16, 185, 129, 0.35));
        }
        50% {
          transform: translateY(-8px) scale(1.05);
          filter: drop-shadow(0 28px 38px rgba(16, 185, 129, 0.45));
        }
      }

      @keyframes bubble-sway {
        0%,
        100% {
          transform: translateY(0) rotate(-3deg);
        }
        50% {
          transform: translateY(-14px) rotate(3deg);
        }
      }

      @keyframes bubble-breathe {
        0%,
        100% {
          transform: scale(0.98) translateY(0);
        }
        50% {
          transform: scale(1.02) translateY(-6px);
        }
      }

      @keyframes bubble-halo {
        0%,
        100% {
          opacity: 0.75;
          transform: scale(1);
        }
        50% {
          opacity: 1;
          transform: scale(1.05);
        }
      }

      @keyframes bubble-twinkle {
        0%,
        100% {
          opacity: 0.35;
          transform: scale(0.8) rotate(-6deg);
        }
        50% {
          opacity: 1;
          transform: scale(1.15) rotate(6deg);
        }
      }

      @keyframes bubble-button-pop {
        0%,
        100% {
          transform: scale(1);
        }
        40% {
          transform: scale(1.08);
        }
        55% {
          transform: scale(0.96);
        }
        70% {
          transform: scale(1.04);
        }
      }

      @keyframes flash {
        0%,
        50%,
        100% {
          opacity: 1;
        }
        25%,
        75% {
          opacity: 0;
        }
      }

      .flash {
        animation: flash 1s infinite;
      }

      .glitch-active .glitch-main {
        animation: logo-glitch-base 1.1s steps(2, end);
      }
      .glitch-active .glitch-layer--red {
        animation: logo-glitch-layer-red 1.1s steps(2, end);
      }
      .glitch-active .glitch-layer--cyan {
        animation: logo-glitch-layer-cyan 1.1s steps(2, end);
      }

      .powerup {
        position: absolute;
        width: 86px;
        height: auto;
        z-index: 25;
        pointer-events: auto;
        cursor: pointer;
        filter: drop-shadow(0 18px 32px rgba(16, 185, 129, 0.45));
        animation: powerup-float 2.4s ease-in-out infinite;
        transition: transform 0.3s ease, opacity 0.3s ease;
      }

      .powerup:active {
        transform: scale(0.92);
      }

      .powerup--vanish {
        opacity: 0;
        transform: translateY(30px) scale(0.65);
      }

      @keyframes powerup-float {
        0%,
        100% {
          transform: translateY(0) scale(1);
        }
        50% {
          transform: translateY(-12px) scale(1.04);
        }
      }

      .foam-burst {
        position: absolute;
        width: 260px;
        height: 260px;
        margin-left: -130px;
        margin-top: -130px;
        pointer-events: none;
        background: radial-gradient(
            circle at 30% 30%,
            rgba(255, 255, 255, 0.95),
            rgba(255, 255, 255, 0.15) 70%
          ),
          radial-gradient(
            circle at 70% 40%,
            rgba(209, 250, 229, 0.9),
            rgba(6, 95, 70, 0.15) 70%
          );
        border-radius: 50%;
        opacity: 0;
        transform: scale(0.3);
        transition: transform 0.4s ease-out, opacity 0.4s ease-out;
        box-shadow: 0 18px 42px rgba(16, 185, 129, 0.45);
      }

      .foam-burst.is-visible {
        opacity: 0.85;
        transform: scale(1);
      }

      #sparkleHud {
        position: absolute;
        top: calc(env(safe-area-inset-top, 0px) + 1.5rem);
        left: 50%;
        transform: translateX(-50%);
        width: min(90vw, 520px);
        z-index: 30;
      }

      #progressShell {
        position: relative;
        overflow: hidden;
        border-radius: 9999px;
        background: linear-gradient(135deg, rgba(16, 185, 129, 0.22), rgba(6, 95, 70, 0.45));
        border: 2px solid rgba(16, 185, 129, 0.65);
        box-shadow: inset 0 4px 12px rgba(15, 118, 110, 0.25), 0 18px 32px rgba(16, 185, 129, 0.35);
        padding: 0.85rem 1.2rem;
      }

      #progressFill {
        position: absolute;
        inset: 0;
        width: 0%;
        border-radius: inherit;
        background: linear-gradient(135deg, rgba(190, 242, 100, 0.9), rgba(14, 165, 233, 0.9));
        transition: width 0.35s ease-out;
      }

      #progressLabel {
        position: relative;
        z-index: 1;
      }

      #timerShell {
        position: absolute;
        top: calc(env(safe-area-inset-top, 0px) + 1rem);
        left: calc(env(safe-area-inset-left, 0px) + 1rem);
        z-index: 30;
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 0.35rem;
      }

      #timerShell .timer-label {
        padding: 0.3rem 0.75rem;
        border-radius: 9999px;
        font-size: 0.7rem;
        letter-spacing: 0.3em;
        font-weight: 700;
        text-transform: uppercase;
        color: rgba(236, 253, 245, 0.9);
        background: rgba(13, 148, 136, 0.6);
        backdrop-filter: blur(4px);
      }

      #timerShell #timer {
        padding: 0.65rem 1.6rem;
        border-radius: 1.75rem;
        font-size: clamp(2.8rem, 4vw, 3.6rem);
        font-weight: 900;
        color: white;
        background: linear-gradient(145deg, rgba(5, 150, 105, 0.95), rgba(16, 185, 129, 0.85));
        box-shadow: 0 18px 34px rgba(5, 150, 105, 0.45);
        line-height: 1;
        min-width: 4.5rem;
        text-align: center;
      }

      #powerupToast {
        position: absolute;
        top: calc(env(safe-area-inset-top, 0px) + 7.5rem);
        left: 50%;
        transform: translate(-50%, 14px);
        z-index: 40;
        padding: 0.85rem 1.6rem;
        border-radius: 1.5rem;
        font-weight: 700;
        font-size: 1.05rem;
        letter-spacing: 0.03em;
        color: white;
        background: linear-gradient(135deg, rgba(16, 185, 129, 0.92), rgba(59, 130, 246, 0.85));
        box-shadow: 0 14px 28px rgba(16, 185, 129, 0.35);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease, transform 0.3s ease;
      }

      #powerupToast[data-visible="true"] {
        opacity: 1;
        transform: translate(-50%, 0);
      }

      #powerupToast[data-tone="rose"] {
        background: linear-gradient(135deg, rgba(244, 63, 94, 0.95), rgba(251, 191, 36, 0.85));
        box-shadow: 0 14px 28px rgba(244, 63, 94, 0.35);
      }

      #streakBadge {
        position: absolute;
        bottom: calc(env(safe-area-inset-bottom, 0px) + 1.5rem);
        left: 50%;
        transform: translateX(-50%);
        padding: 0.65rem 1.6rem;
        border-radius: 1.75rem;
        font-weight: 800;
        font-size: 1rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: rgba(6, 78, 59, 0.95);
        background: rgba(209, 250, 229, 0.92);
        box-shadow: 0 16px 32px rgba(16, 185, 129, 0.35);
        backdrop-filter: blur(4px);
        text-align: center;
        z-index: 30;
      }

      @media (max-width: 640px) {
        #sparkleHud {
          top: calc(env(safe-area-inset-top, 0px) + 1rem);
        }
        #powerupToast {
          top: calc(env(safe-area-inset-top, 0px) + 6.5rem);
          font-size: 0.95rem;
        }
        #streakBadge {
          font-size: 0.85rem;
        }
      }

      @keyframes logo-glitch-base {
        0%,
        12%,
        20%,
        55%,
        65%,
        82%,
        90%,
        100% {
          transform: translate3d(0, 0, 0);
        }
        13% {
          transform: translate3d(-5px, 2px, 0) skewX(-4deg);
        }
        15% {
          transform: translate3d(5px, -3px, 0) skewX(3deg);
        }
        18% {
          transform: translate3d(-3px, 2px, 0);
        }
        56% {
          transform: translate3d(4px, -2px, 0) skewX(2deg);
        }
        60% {
          transform: translate3d(-4px, 3px, 0) skewX(-2deg);
        }
        83% {
          transform: translate3d(-3px, -3px, 0);
        }
        86% {
          transform: translate3d(4px, 2px, 0);
        }
      }

      @keyframes logo-glitch-layer-red {
        0%,
        12%,
        20%,
        55%,
        63%,
        82%,
        86%,
        100% {
          opacity: 0;
          transform: translate3d(0, 0, 0);
          clip-path: inset(0 0 0 0);
        }
        13% {
          opacity: 0.85;
          transform: translate3d(-6px, -4px, 0);
          clip-path: inset(0 0 60% 0);
        }
        15% {
          opacity: 0.85;
          transform: translate3d(5px, 2px, 0);
          clip-path: inset(40% 0 0 0);
        }
        18% {
          opacity: 0;
        }
        56% {
          opacity: 0.75;
          transform: translate3d(-4px, 2px, 0);
          clip-path: inset(0 0 70% 0);
        }
        60% {
          opacity: 0.75;
          transform: translate3d(4px, -2px, 0);
          clip-path: inset(30% 0 0 0);
        }
        83% {
          opacity: 0.9;
          transform: translate3d(-5px, 0, 0);
          clip-path: inset(10% 0 35% 0);
        }
      }

      @keyframes logo-glitch-layer-cyan {
        0%,
        12%,
        20%,
        55%,
        60%,
        80%,
        87%,
        100% {
          opacity: 0;
          transform: translate3d(0, 0, 0);
          clip-path: inset(0 0 0 0);
        }
        13% {
          opacity: 0.85;
          transform: translate3d(5px, 2px, 0);
          clip-path: inset(35% 0 0 0);
        }
        15% {
          opacity: 0.85;
          transform: translate3d(-4px, -2px, 0);
          clip-path: inset(0 0 35% 0);
        }
        18% {
          opacity: 0;
        }
        57% {
          opacity: 0.7;
          transform: translate3d(4px, -3px, 0);
          clip-path: inset(15% 0 35% 0);
        }
        84% {
          opacity: 0.8;
          transform: translate3d(4px, 3px, 0);
          clip-path: inset(55% 0 0 0);
        }
      }
    </style>
  </head>
  <body class="h-full bg-white overflow-hidden">
    <!-- Attract / Start Screen -->
    <div
      id="startScreen"
      class="absolute inset-0 flex flex-col items-center justify-start lg:justify-center gap-12 bg-gradient-to-b from-emerald-50 via-white to-white touch-none select-none px-6 pt-24 pb-16 md:pt-28 md:pb-20 overflow-y-auto"
    >
      <div class="w-full max-w-6xl flex flex-col items-center gap-12 xl:flex-row xl:items-start xl:justify-center xl:gap-16">
        <div class="flex-1 max-w-3xl flex flex-col items-center gap-8">
          <div class="w-full">
            <div
              class="flex flex-col items-center gap-6 rounded-[32px] border border-emerald-100/70 bg-white/90 px-8 pt-12 pb-10 shadow-[0_25px_60px_rgba(16,185,129,0.18)] backdrop-blur-sm md:px-12"
            >
              <div class="w-full flex justify-center">
                <div
                  id="logo"
                  class="glitch-shell relative w-64 sm:w-72 md:w-80 max-w-sm drop-shadow-2xl transition-transform duration-700 ease-out"
                >
                  <img
                    src="https://www.dublincleaners.com/wp-content/uploads/2025/06/LogosHQ.png"
                    alt="Dublin Cleaners"
                    class="glitch-main"
                  />
                  <img
                    src="https://www.dublincleaners.com/wp-content/uploads/2025/06/LogosHQ.png"
                    alt=""
                    aria-hidden="true"
                    class="glitch-layer glitch-layer--red"
                  />
                  <img
                    src="https://www.dublincleaners.com/wp-content/uploads/2025/06/LogosHQ.png"
                    alt=""
                    aria-hidden="true"
                    class="glitch-layer glitch-layer--cyan"
                  />
                </div>
              </div>
              <div class="text-center">
                <div class="text-5xl font-black tracking-tight text-emerald-900">
                  Stain Blaster
                </div>
                <div class="mt-4 text-lg md:text-xl text-emerald-700/80">
                  Swipe the stains away in 12 seconds for cleaning tips, prizes,
                  and exclusive Dublin Cleaners discounts.
                </div>
              </div>
            </div>
          </div>
          <div class="text-xl text-stone-500 text-center max-w-2xl">
            Tap every stain off this shirt in 12 seconds to keep the garment
            spotless and your prize streak alive!
          </div>
          <div class="flex flex-col items-center gap-3">
            <div class="bubble-wow">
              <img
                src="https://www.dublincleaners.com/wp-content/uploads/2025/10/bubble.png"
                alt="Glowing soap bubble"
                class="bubble-wow__image"
              />
              <div
                class="bubble-wow__sparkle bubble-wow__sparkle--one"
                aria-hidden="true"
              ></div>
              <div
                class="bubble-wow__sparkle bubble-wow__sparkle--two"
                aria-hidden="true"
              ></div>
              <div
                class="bubble-wow__sparkle bubble-wow__sparkle--three"
                aria-hidden="true"
              ></div>
              <button
                id="playBtn"
                class="bubble-wow__button px-8 py-4 text-2xl shadow-lg focus:outline-none focus-visible:ring-4 focus-visible:ring-emerald-200"
              >
                Pop to Play!
              </button>
            </div>
            <div class="bubble-wow__caption text-emerald-700 text-xs md:text-sm font-semibold text-center">
              Tap the magic bubble to launch the suds cannon
            </div>
          </div>
        </div>
        <div class="flex-1 w-full max-w-xl flex flex-col items-center xl:items-stretch gap-6">
          <div class="grid gap-3 text-base text-stone-600 text-left w-full">
            <div class="rounded-2xl bg-emerald-50/90 px-5 py-3 shadow-inner">
              <span class="text-2xl mr-2">🧼</span>
              Race the timer and blast each splatter—no rule changes, just a
              sudsy remix of the classic challenge you know.
            </div>
            <div class="rounded-2xl bg-emerald-50/90 px-5 py-3 shadow-inner">
              <span class="text-2xl mr-2">🎯</span>
              Build streaks to flex your skills and unlock bigger bragging
              rights while the difficulty ramps up each win.
            </div>
            <div class="rounded-2xl bg-emerald-50/90 px-5 py-3 shadow-inner">
              <span class="text-2xl mr-2">💥</span>
              Watch for surprise soap bars—snag one for a bubbly boost without
              breaking the odds or prize tables.
            </div>
          </div>
          <div class="text-xs text-stone-400 text-center xl:text-left w-full">
            Disclaimer<br />
            By pressing "Play Now", you understand this content provides general
            fabric care tips only. Always follow the care labels on your
            garments and be aware of any restrictions. Use these tips at your
            own risk—Dublin Cleaners is not responsible for any damage that may
            result from misuse or disregard of proper care instructions.
          </div>
        </div>
      </div>
      <div class="text-xl text-stone-500 text-center">
        Tap every stain off this shirt in 12 seconds to keep the garment
        spotless and your prize streak alive!
      </div>
      <div class="grid gap-3 text-base text-stone-600 text-left max-w-xl px-4">
        <div class="rounded-2xl bg-emerald-50/90 px-5 py-3 shadow-inner">
          <span class="text-2xl mr-2">🧼</span>
          Race the timer and blast each splatter—no rule changes, just a sudsy
          remix of the classic challenge you know.
        </div>
        <div class="rounded-2xl bg-emerald-50/90 px-5 py-3 shadow-inner">
          <span class="text-2xl mr-2">🎯</span>
          Build streaks to flex your skills and unlock bigger bragging rights
          while the difficulty ramps up each win.
        </div>
        <div class="rounded-2xl bg-emerald-50/90 px-5 py-3 shadow-inner">
          <span class="text-2xl mr-2">💥</span>
          Watch for surprise soap bars—snag one for a bubbly boost without
          breaking the odds or prize tables.
        </div>
      </div>
      <div class="flex flex-col items-center gap-3">
        <div class="bubble-wow" id="playBubble">
          <img
            src="https://www.dublincleaners.com/wp-content/uploads/2025/10/bubble.png"
            alt="Glowing soap bubble"
            class="bubble-wow__image"
          />
          <div
            class="bubble-wow__sparkle bubble-wow__sparkle--one"
            aria-hidden="true"
          ></div>
          <div
            class="bubble-wow__sparkle bubble-wow__sparkle--two"
            aria-hidden="true"
          ></div>
          <div
            class="bubble-wow__sparkle bubble-wow__sparkle--three"
            aria-hidden="true"
          ></div>
          <button
            id="playBtn"
            class="bubble-wow__button px-8 py-4 text-2xl shadow-lg focus:outline-none focus-visible:ring-4 focus-visible:ring-emerald-200"
          >
            Pop to Play!
          </button>
        </div>
        <div class="bubble-wow__caption text-emerald-700 text-xs md:text-sm font-semibold text-center">
          Tap the magic bubble to launch the suds cannon
        </div>
      </div>
      <div class="text-xs text-stone-400 text-center max-w-md px-4">
        Disclaimer<br />
        By pressing "Play Now", you understand this content provides general
        fabric care tips only. Always follow the care labels on your garments
        and be aware of any restrictions. Use these tips at your own risk—Dublin
        Cleaners is not responsible for any damage that may result from misuse
        or disregard of proper care instructions.
      </div>
      <div
        id="attractCannon"
        class="glitch-shell glitch-cannon glitch-cannon--bottom-right select-none"
        aria-hidden="true"
      >
        <img
          src="https://www.dublincleaners.com/wp-content/uploads/2025/08/Canon.png"
          alt=""
          class="glitch-main"
        />
        <img
          src="https://www.dublincleaners.com/wp-content/uploads/2025/08/Canon.png"
          alt=""
          class="glitch-layer glitch-layer--red"
        />
        <img
          src="https://www.dublincleaners.com/wp-content/uploads/2025/08/Canon.png"
          alt=""
          class="glitch-layer glitch-layer--cyan"
        />
      </div>
    </div>


    <!-- Game Area -->
    <div
      id="gameArea"
      class="absolute inset-0 hidden bg-[url('https://www.dublincleaners.com/wp-content/uploads/2025/08/Whiteshirt.png')] bg-cover"
    >
      <div id="sparkleHud" class="flex flex-col items-center gap-3 text-center">
        <div
          class="inline-flex items-center gap-2 rounded-full bg-emerald-600/90 px-5 py-2 text-xs font-black uppercase tracking-[0.35em] text-emerald-50 shadow-lg backdrop-blur-sm"
        >
          Spotless Mission
        </div>
        <div id="progressShell">
          <div id="progressFill"></div>
          <div
            id="progressLabel"
            class="text-sm font-semibold text-emerald-950 drop-shadow-sm md:text-base"
          >
            Tap stains to fill the meter!
          </div>
        </div>
      </div>
      <div id="timerShell">
        <div class="timer-label">Seconds Left</div>
        <div id="timer">12</div>
      </div>
      <div id="powerupToast"></div>
      <div id="streakBadge">Spotless streak starts now!</div>
      <!-- stains injected here -->
      <div
        id="cannon"
        class="glitch-shell glitch-cannon glitch-cannon--bottom-right select-none"
        aria-hidden="true"
      >
        <img
          src="https://www.dublincleaners.com/wp-content/uploads/2025/08/Canon.png"
          alt=""
          class="glitch-main"
        />
        <img
          src="https://www.dublincleaners.com/wp-content/uploads/2025/08/Canon.png"
          alt=""
          class="glitch-layer glitch-layer--red"
        />
        <img
          src="https://www.dublincleaners.com/wp-content/uploads/2025/08/Canon.png"
          alt=""
          class="glitch-layer glitch-layer--cyan"
        />
      </div>
    </div>

    <!-- Result Screen -->
    <div
      id="resultScreen"
      class="absolute inset-0 hidden flex flex-col items-center justify-center gap-6 bg-white text-center"
    >
      <div
        id="resultText"
        class="flex flex-col items-center gap-4 text-center"
      ></div>
      <div id="qrWrap" class="p-4 bg-stone-100 rounded-2xl shadow-inner"></div>
      <button
        id="restartBtn"
        class="mt-8 px-6 py-3 bg-emerald-600 text-white text-2xl rounded-2xl shadow-lg active:scale-95 transition"
      >
        Play Again
      </button>
    </div>

    <div
      id="highScoreModal"
      class="hidden absolute inset-0 z-[120] flex items-center justify-center bg-emerald-950/80 px-4"
      role="dialog"
      aria-modal="true"
      aria-labelledby="highScoreModalTitle"
    >
      <div
        class="w-full max-w-3xl rounded-[2.5rem] border-4 border-emerald-500 bg-white px-6 py-8 text-center shadow-2xl md:px-12 md:py-12"
      >
        <div
          id="highScoreModalTitle"
          class="text-4xl font-black uppercase tracking-wide text-emerald-600 drop-shadow"
        >
          New Su-Stained High Score!
        </div>
        <div class="mt-4 text-lg text-stone-600">
          Touch the keyboard below to add your name to the leaderboard.
        </div>
        <div class="mt-6">
          <input
            id="highScoreNameInput"
            type="text"
            inputmode="none"
            autocomplete="off"
            maxlength="18"
            readonly
            class="w-full rounded-[1.75rem] border-4 border-emerald-500 bg-emerald-50 px-6 py-4 text-center text-3xl font-black tracking-widest text-emerald-700 shadow-inner"
            placeholder="ENTER YOUR NAME"
          />
          <div id="highScoreNotice" class="mt-2 h-6 text-sm font-semibold text-rose-500"></div>
        </div>
        <div id="highScoreKeyboard" class="mt-6 flex flex-col items-center gap-4">
          <div class="kb-row">
            <button class="kb-key" data-key="Q">Q</button>
            <button class="kb-key" data-key="W">W</button>
            <button class="kb-key" data-key="E">E</button>
            <button class="kb-key" data-key="R">R</button>
            <button class="kb-key" data-key="T">T</button>
            <button class="kb-key" data-key="Y">Y</button>
            <button class="kb-key" data-key="U">U</button>
            <button class="kb-key" data-key="I">I</button>
            <button class="kb-key" data-key="O">O</button>
            <button class="kb-key" data-key="P">P</button>
          </div>
          <div class="kb-row">
            <button class="kb-key" data-key="A">A</button>
            <button class="kb-key" data-key="S">S</button>
            <button class="kb-key" data-key="D">D</button>
            <button class="kb-key" data-key="F">F</button>
            <button class="kb-key" data-key="G">G</button>
            <button class="kb-key" data-key="H">H</button>
            <button class="kb-key" data-key="J">J</button>
            <button class="kb-key" data-key="K">K</button>
            <button class="kb-key" data-key="L">L</button>
          </div>
          <div class="kb-row">
            <button class="kb-key" data-key="Z">Z</button>
            <button class="kb-key" data-key="X">X</button>
            <button class="kb-key" data-key="C">C</button>
            <button class="kb-key" data-key="V">V</button>
            <button class="kb-key" data-key="B">B</button>
            <button class="kb-key" data-key="N">N</button>
            <button class="kb-key" data-key="M">M</button>
            <button class="kb-key kb-key--wide" data-key="BACKSPACE">⌫</button>
          </div>
          <div class="kb-row">
            <button class="kb-key kb-key--xl" data-key="SPACE">Space</button>
            <button class="kb-key kb-key--wide kb-key--secondary" data-key="CLEAR">Clear</button>
          </div>
          <div class="kb-row">
            <button id="skipHighScoreBtn" class="kb-key kb-key--wide kb-key--secondary" type="button">
              Skip
            </button>
            <button id="saveHighScoreBtn" class="kb-key kb-key--wide kb-key--action" type="button">
              Save Name
            </button>
          </div>
        </div>
      </div>
    </div>

    <div
      id="highScore"
      class="hidden absolute top-2 right-2 z-50 flex flex-col items-center justify-center gap-1 rounded-lg bg-emerald-600 px-5 py-3 text-center text-white shadow-lg"
    ></div>

    <script>
      (async () => {
        // Fallback prize picker in case the module fails to load. This
        // mirrors the logic in prize.js so kiosk users still receive
        // monetary rewards even if dynamic import is blocked.
        let pickPrize = (level) => {
          const prizes = [
            { tier: "Common", probability: 0.6, reward: null, minLevel: 1 },
            {
              tier: "Uncommon",
              probability: 0.25,
              reward: "$5 cleaning credit",
              minLevel: 1,
            },
            {
              tier: "Rare",
              probability: 0.12,
              reward: "$10 cleaning credit",
              minLevel: 2,
            },
            {
              tier: "Epic",
              probability: 0.03,
              reward: "$50 premium garment credit",
              minLevel: 3,
            },
          ];
          const fallback = prizes.find((p) => level >= p.minLevel) || prizes[0];
          const r = Math.random();
          let cumulative = 0;
          for (const p of prizes) {
            cumulative += p.probability;
            if (r < cumulative) {
              return level >= p.minLevel ? p : fallback;
            }
          }
          return fallback;
        };
        try {
          ({ pickPrize } = await import("./prize.js"));
        } catch (err) {
          console.error("Failed to load prize module", err);
        }
        /* ----- Config ----- */

        const BASE_STAIN_START = 23; // initial stains
        const BASE_STAIN_SIZE = 90; // px
        const BASE_FIRE_RATE = 3000; // ms per extra stain
        const TOP_MARGIN = 50;
        const BOTTOM_MARGIN = 100;
        const HIGH_SCORE_CLEARANCE = 16;
        const DEVICE = "kiosk";
        const GAME_TIME = 12; // seconds per round
        const RESET_DELAY = 60000; // ms before auto reset (4x longer)
        const ACTIVE_CANNON_CORNER = "glitch-cannon--bottom-right";
        const ALL_CANNON_CORNER_CLASSES = [
          "glitch-cannon--top-left",
          "glitch-cannon--bottom-left",
          "glitch-cannon--bottom-right",
        ];
        const CANNON_MOUTH_OFFSETS = {
          "glitch-cannon--top-left": { x: 0.88, y: 0.36 },
          "glitch-cannon--bottom-left": { x: 0.88, y: 0.36 },
          "glitch-cannon--bottom-right": { x: 0.88, y: 0.36 },
        };
        const ATTRACT_CANNON_IDLE_ANGLE = (-3 * Math.PI) / 4;

        let STAIN_START = BASE_STAIN_START;
        let STAIN_SIZE = BASE_STAIN_SIZE;
        let FIRE_RATE = BASE_FIRE_RATE;
        let winStreak = 0;
        let timeOffset = 0; // server vs client clock diff
        let resetTimer;

        if (typeof google !== "undefined") {
          google.script.run
            .withSuccessHandler((t) => {
              timeOffset = t - Date.now();
            })
            .getServerTime();
        }

        function now() {
          return Date.now() + timeOffset;
        }

        function applyDifficulty() {
          STAIN_SIZE = BASE_STAIN_SIZE / Math.pow(1.2, winStreak);
          STAIN_START = Math.round(
            BASE_STAIN_START * Math.pow(1.15, winStreak),
          );
          FIRE_RATE = BASE_FIRE_RATE * Math.pow(0.85, winStreak);
        }

        function computeTopMargin(areaRect = gameArea.getBoundingClientRect()) {
          const base = TOP_MARGIN;
          if (
            !areaRect ||
            highScoreEl.classList.contains("hidden") ||
            highScoreEl.offsetWidth === 0 ||
            highScoreEl.offsetHeight === 0
          ) {
            return base;
          }
          const scoreRect = highScoreEl.getBoundingClientRect();
          if (!scoreRect || (!scoreRect.width && !scoreRect.height)) {
            return base;
          }
          const clearance =
            scoreRect.bottom - areaRect.top + HIGH_SCORE_CLEARANCE;
          return Math.max(base, clearance);
        }
        const STAIN_IMAGES = [
          "https://www.dublincleaners.com/wp-content/uploads/2025/08/Ketchup.png",
          "https://www.dublincleaners.com/wp-content/uploads/2025/08/Coffee.png",
          "https://www.dublincleaners.com/wp-content/uploads/2025/08/Dirt.png",
          "https://www.dublincleaners.com/wp-content/uploads/2025/08/Wine.png",
        ];
        const SOAP_POWERUP_IMAGE =
          "https://www.dublincleaners.com/wp-content/uploads/2025/10/soap.png";
        const POWERUP_MIN_DELAY = 3600; // ms
        const POWERUP_MAX_DELAY = 6800; // ms
        const POWERUP_LIFETIME = 4200; // ms soap visible
        const POWERUP_MAX_CLEARS = 3;
        const SOAP_SLOW_DURATION = 2200; // ms pause on cannon
        const POWERUP_TOAST_DURATION = 2400; // ms toast visibility
        const BUBBLE_LINES = [
          "Think you can wipe all the stains?",
          "Eco cleaning tips & discounts await!",
          "Swipe fast – win prizes toward your dry cleaning bill!",
          "Spotless skills? Earn dry-cleaning credits!",
          "Tap ▶ to blast, learn & save!",
          "Your dry-cleaner believes in you 😎",
          "Beat the Su-Stained High Score!!",
        ];
        const BUBBLE_INTERVAL = 4000; // ms between spawns
        const BUBBLE_JITTER = 1000; // ms random jitter
        const BUBBLE_DURATION = 5000; // ms visible
        const LOGO_GLITCH_INTERVAL = 9000; // ms between glitch triggers
        const LOGO_GLITCH_JITTER = 3000; // ms random offset
        const LOGO_GLITCH_DURATION = 1100; // ms animation length
        const TIP_DISCLAIMER =
          "\n\n<em>Ensure safe for care labels and understand restrictions. ATTEMPT AT YOUR OWN RISK – we are not responsible for any damage you cause to your garment.</em>";
        const cleaningTips = [
          "🧼 <strong>Always blot, never rub</strong>\nSpilled wine or coffee? Gently blot with a clean white cloth—rubbing pushes the stain deeper and can damage delicate fibers." +
            TIP_DISCLAIMER,
          "🚫 <strong>Skip the DIY vinegar on silk</strong>\nNatural doesn’t always mean safe. For fine fabrics like silk or wool, avoid vinegar or baking soda—let a textile expert handle it." +
            TIP_DISCLAIMER,
          "👗 <strong>Use garment bags for more than travel</strong>\nProtect your cashmere, gowns, and couture pieces with breathable garment bags—especially in humid or scented closets." +
            TIP_DISCLAIMER,
          "⏱️ <strong>Treat stains fast—but gently</strong>\nIf you can’t get to us right away, lightly dampen the stain with cold water. Don’t apply heat or soap—it could set the stain permanently." +
            TIP_DISCLAIMER,
          "🌬️ <strong>Air out, don’t over-wash</strong>\nFor suits, coats, and dresses, let them breathe between wears. Over-cleaning can shorten the life of premium fabrics." +
            TIP_DISCLAIMER,
          "📎 <strong>Dry cleaning tags go on the hanger, not the sleeve</strong>\nKeep those paper sleeves off your garments. We return items pressed and ready—hang them, store them, wear them." +
            TIP_DISCLAIMER,
          "💨 <strong>Use a steamer, not an iron</strong>\nSteaming is gentler on delicate fabrics and helps preserve the finish. Perfect for touch-ups between professional cleanings." +
            TIP_DISCLAIMER,
          "👔 <strong>Mind your collars and cuffs</strong>\nThese spots collect oils, makeup, and sweat. If you want your shirts to last longer, pre-treat them or clean them more often." +
            TIP_DISCLAIMER,
          "🪵 <strong>Skip the wire hangers</strong>\nInvest in wooden or padded hangers. Wire hangers can misshape shoulders and leave rust or stretch marks." +
            TIP_DISCLAIMER,
          "🌱 <strong>Eco-cleaning matters—ask your cleaner</strong>\nAt Dublin Cleaners, we use biodegradable solvents that are gentle on fabrics and the planet. Garment care without the guilt." +
            TIP_DISCLAIMER,
        ];

        function genCode() {
          const now = new Date();
          const stamp =
            now.getFullYear().toString() +
            String(now.getMonth() + 1).padStart(2, "0") +
            String(now.getDate()).padStart(2, "0") +
            String(now.getHours()).padStart(2, "0") +
            String(now.getMinutes()).padStart(2, "0") +
            String(now.getSeconds()).padStart(2, "0");
          const rand = Math.random().toString(36).slice(2, 7).toUpperCase();
          return `${stamp}-${rand}`;
        }

        /* ----- DOM refs ----- */
        const startScreen = document.getElementById("startScreen");
        const gameArea = document.getElementById("gameArea");
        const timerEl = document.getElementById("timer");
        const cannon = document.getElementById("cannon");
        const attractCannon = document.getElementById("attractCannon");
        const resultScreen = document.getElementById("resultScreen");
        const resultText = document.getElementById("resultText");
        const qrWrap = document.getElementById("qrWrap");
        const logo = document.getElementById("logo");
        const playBtn = document.getElementById("playBtn");
        const playBubble = document.getElementById("playBubble");
        const highScoreEl = document.getElementById("highScore");
        const powerupToast = document.getElementById("powerupToast");
        const progressFill = document.getElementById("progressFill");
        const progressLabel = document.getElementById("progressLabel");
        const streakBadge = document.getElementById("streakBadge");
        const highScoreModal = document.getElementById("highScoreModal");
        const highScoreNameInput = document.getElementById("highScoreNameInput");
        const highScoreKeyboard = document.getElementById("highScoreKeyboard");
        const highScoreNotice = document.getElementById("highScoreNotice");
        const saveHighScoreBtn = document.getElementById("saveHighScoreBtn");
        const skipHighScoreBtn = document.getElementById("skipHighScoreBtn");
        const DEFAULT_HIGH_SCORE_NAME = "STAIN CHAMP";
        const MAX_NAME_LENGTH = 18;
        let pendingHighScore = null;
        let pendingHighScoreTimestamp = 0;
        let remaining,
          total,
          seconds,
          countdown,
          startTime,
          fireInterval,
          bubbleTimer,
          logoTimer,
          fireResumeTimer,
          powerUpTimer,
          powerUpLifetimeTimer,
          powerupToastTimer,
          resultShown = false;

        const glitchTimers = new Map();

        let activePowerUp = null;
        let isRoundActive = false;

        let inMemoryHighScore = { score: 0, name: "", timestamp: 0 };

        function sanitizeName(name) {
          return String(name || "")
            .replace(/[^A-Za-z0-9 .,'&-]/g, "")
            .replace(/\s+/g, " ")
            .trim()
            .toUpperCase()
            .slice(0, MAX_NAME_LENGTH);
        }

        function loadHighScore() {
          try {
            const stored = localStorage.getItem("sbHighScore");
            if (stored) {
              const parsed = JSON.parse(stored);
              const normalized = {
                score: Math.max(0, Math.floor(Number(parsed?.score) || 0)),
                name: sanitizeName(parsed?.name),
                timestamp:
                  parsed?.timestamp && Number(parsed.timestamp) > 0
                    ? Number(parsed.timestamp)
                    : 0,
              };
              inMemoryHighScore = normalized;
              return normalized;
            }
          } catch {}
          return inMemoryHighScore;
        }

        function saveHighScore(record) {
          const normalizedScore = Math.max(
            0,
            Math.floor(Number(record?.score) || 0),
          );
          const normalizedName = sanitizeName(record?.name);
          const normalizedTimestamp =
            record?.timestamp && Number(record.timestamp) > 0
              ? Number(record.timestamp)
              : normalizedScore > 0
              ? Date.now()
              : 0;
          const normalized = {
            score: normalizedScore,
            name:
              normalizedScore > 0
                ? normalizedName || DEFAULT_HIGH_SCORE_NAME
                : "",
            timestamp: normalizedTimestamp,
          };
          try {
            localStorage.setItem("sbHighScore", JSON.stringify(normalized));
          } catch {}
          inMemoryHighScore = normalized;
          return normalized;
        }

        function updateHighScoreDisplay() {
          const { score, name, timestamp } = loadHighScore();
          if (score > 0) {
            const holder = name || "???";
            const parts = [
              '<div class="text-xs uppercase tracking-wide opacity-90">Su-Stained High Score</div>',
              `<div class="text-4xl font-black leading-tight">${score}</div>`,
              `<div class="text-sm font-semibold">Champion: ${holder}</div>`,
            ];
            if (timestamp > 0) {
              parts.push(
                `<div class="text-[0.7rem] opacity-80">${new Date(
                  timestamp,
                ).toLocaleString()}</div>`,
              );
            }
            highScoreEl.innerHTML = parts.join("");
          } else {
            highScoreEl.innerHTML =
              '<div class="text-xs uppercase tracking-wide opacity-90">Su-Stained High Score</div><div class="text-4xl font-black leading-tight">0</div><div class="text-sm font-semibold">Be the first to set it!</div>';
          }
        }

        function isNewHighScore(score) {
          const { score: prev } = loadHighScore();
          return score > prev;
        }

        function showHighScoreNameEntry(score) {
          pendingHighScore = Math.max(0, Math.floor(score));
          highScoreNameInput.value = "";
          highScoreNotice.textContent = "";
          pendingHighScoreTimestamp = Date.now();
          highScoreModal.classList.remove("hidden");
        }

        function hideHighScoreNameEntry() {
          highScoreModal.classList.add("hidden");
          pendingHighScore = null;
          pendingHighScoreTimestamp = 0;
        }

        function handleVirtualKeyPress(key) {
          if (pendingHighScore === null) return;
          let value = highScoreNameInput.value;
          highScoreNotice.textContent = "";
          if (key === "BACKSPACE") {
            highScoreNameInput.value = value.slice(0, -1);
            return;
          }
          if (key === "CLEAR") {
            highScoreNameInput.value = "";
            return;
          }
          if (key === "SPACE") {
            if (!value.length) {
              highScoreNotice.textContent = "Add some letters first.";
              return;
            }
            if (value.length >= MAX_NAME_LENGTH) {
              highScoreNotice.textContent = "Max characters reached.";
              return;
            }
            if (!value.endsWith(" ")) {
              highScoreNameInput.value = `${value} `;
            }
            return;
          }
          if (value.length >= MAX_NAME_LENGTH) {
            highScoreNotice.textContent = "Max characters reached.";
            return;
          }
          highScoreNameInput.value = `${value}${key}`.slice(0, MAX_NAME_LENGTH);
        }

        function finalizeHighScore(rawName) {
          if (pendingHighScore === null) return;
          const cleaned = sanitizeName(rawName);
          if (!cleaned) {
            highScoreNotice.textContent =
              "Add at least one letter for your name.";
            return;
          }
          saveHighScore({
            score: pendingHighScore,
            name: cleaned,
            timestamp: pendingHighScoreTimestamp || Date.now(),
          });
          updateHighScoreDisplay();
          hideHighScoreNameEntry();
        }

        function skipHighScoreName() {
          if (pendingHighScore === null) return;
          saveHighScore({
            score: pendingHighScore,
            name: DEFAULT_HIGH_SCORE_NAME,
            timestamp: pendingHighScoreTimestamp || Date.now(),
          });
          updateHighScoreDisplay();
          hideHighScoreNameEntry();
        }

        function randomBetween(min, max) {
          if (max <= min) return min;
          return min + Math.random() * (max - min);
        }

        function updateProgressDisplay() {
          if (!progressFill || !progressLabel) return;
          if (!total) {
            progressFill.style.width = "0%";
            progressLabel.textContent = "Tap stains to fill the meter!";
            return;
          }
          const cleaned = Math.max(0, total - remaining);
          const ratio = Math.max(0, Math.min(1, cleaned / total));
          progressFill.style.width = `${ratio * 100}%`;
          const left = Math.max(0, remaining);
          let vibe = "Keep scrubbing!";
          if (cleaned === 0) {
            vibe = "Make the first splash!";
          } else if (ratio >= 0.85 && left > 0) {
            vibe = "Final polish!";
          } else if (ratio >= 0.5 && left > 0) {
            vibe = "Halfway to spotless!";
          } else if (left <= 5 && left > 0) {
            vibe = "Almost there!";
          }
          if (left === 0 && cleaned > 0) {
            vibe = "Sparkling! Shirt saved!";
          }
          progressLabel.textContent = `${cleaned} cleaned • ${left} left • ${vibe}`;
        }

        function updateStreakBadge() {
          if (!streakBadge) return;
          if (winStreak > 0) {
            const plural = winStreak === 1 ? "" : "s";
            streakBadge.textContent = `Streak ${winStreak}: ${winStreak} win${plural} running!`;
          } else {
            streakBadge.textContent = "Spotless streak starts now!";
          }
        }

        function showPowerupToast(message, tone = "emerald") {
          if (!powerupToast) return;
          powerupToast.textContent = message;
          if (tone === "rose") {
            powerupToast.dataset.tone = "rose";
          } else {
            delete powerupToast.dataset.tone;
          }
          powerupToast.dataset.visible = "true";
          clearTimeout(powerupToastTimer);
          powerupToastTimer = setTimeout(() => {
            hidePowerupToast();
          }, POWERUP_TOAST_DURATION);
        }

        function hidePowerupToast() {
          if (!powerupToast) return;
          clearTimeout(powerupToastTimer);
          delete powerupToast.dataset.visible;
          delete powerupToast.dataset.tone;
        }

        function startFireLoop(rate = FIRE_RATE) {
          clearInterval(fireInterval);
          fireInterval = setInterval(fireCannon, rate);
        }

        function pauseCannon(duration = SOAP_SLOW_DURATION) {
          if (!isRoundActive) return;
          clearInterval(fireInterval);
          clearTimeout(fireResumeTimer);
          fireResumeTimer = setTimeout(() => {
            if (isRoundActive) {
              startFireLoop(FIRE_RATE);
            }
          }, Math.max(0, duration));
        }

        function clearPowerUps() {
          clearTimeout(powerUpTimer);
          clearTimeout(powerUpLifetimeTimer);
          if (activePowerUp && activePowerUp.isConnected) {
            activePowerUp.remove();
          }
          activePowerUp = null;
        }

        function createFoamBurst(x, y) {
          if (!gameArea) return;
          const burst = document.createElement("div");
          burst.className = "foam-burst";
          burst.style.left = `${x}px`;
          burst.style.top = `${y}px`;
          gameArea.appendChild(burst);
          requestAnimationFrame(() => {
            burst.classList.add("is-visible");
          });
          setTimeout(() => burst.remove(), 600);
        }

        function cleanRandomStains(maxCount) {
          const stains = Array.from(gameArea.querySelectorAll(".stain"));
          if (!stains.length) return 0;
          let cleaned = 0;
          for (const stain of stains.sort(() => Math.random() - 0.5)) {
            if (typeof stain.__removeStain === "function") {
              stain.__removeStain();
              cleaned++;
            }
            if (cleaned >= maxCount) break;
          }
          return cleaned;
        }

        function schedulePowerUp(
          delay = randomBetween(POWERUP_MIN_DELAY, POWERUP_MAX_DELAY),
        ) {
          clearTimeout(powerUpTimer);
          if (!isRoundActive) return;
          powerUpTimer = setTimeout(() => {
            if (!isRoundActive) return;
            if (activePowerUp) {
              schedulePowerUp();
              return;
            }
            spawnSoapPowerUp();
          }, Math.max(0, delay));
        }

        function spawnSoapPowerUp() {
          if (!isRoundActive || gameArea.classList.contains("hidden")) {
            return;
          }
          if (activePowerUp && activePowerUp.isConnected) {
            return;
          }
          const rect = gameArea.getBoundingClientRect();
          if (!rect.width || !rect.height) return;
          const soap = document.createElement("img");
          soap.src = SOAP_POWERUP_IMAGE;
          soap.alt = "Sudsy power-up";
          soap.className = "powerup";
          const soapSize = 86;
          const topMargin = computeTopMargin(rect) + 30;
          const spawnW = Math.max(0, rect.width - soapSize);
          const spawnH = Math.max(
            0,
            rect.height - soapSize - topMargin - BOTTOM_MARGIN,
          );
          const x = Math.random() * spawnW;
          const y = Math.random() * spawnH + topMargin;
          soap.style.left = `${x}px`;
          soap.style.top = `${y}px`;
          soap.style.width = `${soapSize}px`;
          soap.dataset.powerup = "soap";
          soap.addEventListener(
            "pointerdown",
            () => activateSoapPowerUp(soap),
            { once: true },
          );
          gameArea.appendChild(soap);
          activePowerUp = soap;
          showPowerupToast("Sudsy surprise! Tap the soap!");
          clearTimeout(powerUpLifetimeTimer);
          powerUpLifetimeTimer = setTimeout(() => {
            if (activePowerUp !== soap) return;
            soap.classList.add("powerup--vanish");
            setTimeout(() => soap.remove(), 250);
            activePowerUp = null;
            showPowerupToast("The soap slipped away!", "rose");
            schedulePowerUp();
          }, POWERUP_LIFETIME);
        }

        function activateSoapPowerUp(soap) {
          if (activePowerUp !== soap) return;
          const areaRect = gameArea.getBoundingClientRect();
          const soapRect = soap.getBoundingClientRect();
          const centerX = soapRect.left - areaRect.left + soapRect.width / 2;
          const centerY = soapRect.top - areaRect.top + soapRect.height / 2;
          soap.remove();
          activePowerUp = null;
          clearTimeout(powerUpLifetimeTimer);
          createFoamBurst(centerX, centerY);
          const cleaned = cleanRandomStains(POWERUP_MAX_CLEARS);
          if (cleaned > 0) {
            showPowerupToast(
              `Foam burst! ${cleaned} stain${cleaned > 1 ? "s" : ""} scrubbed!`,
            );
          } else {
            showPowerupToast("Foam burst! Keep blasting!");
          }
          pauseCannon(SOAP_SLOW_DURATION);
          schedulePowerUp();
        }

        function randomImage() {
          return STAIN_IMAGES[Math.floor(Math.random() * STAIN_IMAGES.length)];
        }

        function randomLine() {
          return BUBBLE_LINES[Math.floor(Math.random() * BUBBLE_LINES.length)];
        }

        function spawnBubble() {
          if (startScreen.classList.contains("hidden")) return;
          if (startScreen.querySelectorAll(".bubble").length >= 3) return;
          const bubble = document.createElement("div");
          bubble.className =
            "bubble max-w-[320px] px-6 py-4 rounded-[2rem] border-[3px] border-emerald-500 bg-gradient-to-br from-white via-emerald-50 to-emerald-100/80 text-emerald-700 font-extrabold text-center text-lg leading-snug tracking-wide shadow-xl ring-4 ring-emerald-200/60 backdrop-blur-sm pointer-events-none";
          bubble.innerHTML = `${randomLine()}<svg class="absolute -top-3 -right-3 w-6 h-6 text-emerald-400 drop-shadow-md" viewBox="0 0 20 20" fill="currentColor"><path d="M10 0l2.09 6.26L18.18 7.5l-5.09 3.7L14.18 18 10 14.27 5.82 18l1.09-6.8L1.82 7.5l6.09-1.24L10 0z"/></svg>`;
          startScreen.appendChild(bubble);
          const rect = startScreen.getBoundingClientRect();
          const maxY = rect.height * 0.6;
          const avoid = [
            logo.getBoundingClientRect(),
            playBtn.getBoundingClientRect(),
          ];
          const bw = bubble.offsetWidth;
          const bh = bubble.offsetHeight;
          const basePaddingX = Math.max(16, rect.width * 0.05);
          const basePaddingY = Math.max(16, rect.height * 0.05);
          const safePaddingX = Math.min(
            basePaddingX,
            Math.max(0, (rect.width - bw) / 2),
          );
          const safePaddingY = Math.min(
            basePaddingY,
            Math.max(0, (maxY - bh) / 2),
          );
          const topLimit = Math.max(
            safePaddingY,
            Math.min(rect.height - safePaddingY - bh, maxY - bh),
          );
          const availableWidth = Math.max(0, rect.width - bw - safePaddingX * 2);
          const availableHeight = Math.max(
            0,
            topLimit - safePaddingY,
          );
          let x,
            y,
            tries = 0,
            ok;
          do {
            x =
              safePaddingX +
              (availableWidth > 0 ? Math.random() * availableWidth : 0);
            y =
              safePaddingY +
              (availableHeight > 0 ? Math.random() * availableHeight : 0);
            ok = !avoid.some((r) => {
              const rx = r.left - rect.left;
              const ry = r.top - rect.top;
              return !(
                x + bw < rx ||
                x > rx + r.width ||
                y + bh < ry ||
                y > ry + r.height
              );
            });
            tries++;
          } while (!ok && tries < 10);
          bubble.style.left = x + "px";
          bubble.style.top = y + "px";
          bubble.style.animation =
            "bubble-in 0.65s cubic-bezier(0.22, 1.28, 0.68, 1.08), bubble-glow 3.8s ease-in-out 0.65s infinite alternate, bubble-out 0.6s ease-in 4.4s forwards";
          setTimeout(() => bubble.remove(), BUBBLE_DURATION);
        }

        function scheduleBubble() {
          if (startScreen.classList.contains("hidden")) return;
          bubbleTimer = setTimeout(
            () => {
              spawnBubble();
              scheduleBubble();
            },
            BUBBLE_INTERVAL + (Math.random() * 2 - 1) * BUBBLE_JITTER,
          );
        }

        function triggerGlitchFor(element) {
          if (!element) return;
          element.classList.remove("glitch-active");
          void element.offsetWidth;
          element.classList.add("glitch-active");
          const timer = glitchTimers.get(element);
          if (timer) {
            clearTimeout(timer);
          }
          const cleanup = setTimeout(() => {
            element.classList.remove("glitch-active");
            glitchTimers.delete(element);
          }, LOGO_GLITCH_DURATION);
          glitchTimers.set(element, cleanup);
        }

        function triggerLogoGlitch() {
          if (!startScreen.classList.contains("hidden")) {
            triggerGlitchFor(logo);
            triggerGlitchFor(attractCannon);
          }
          if (!gameArea.classList.contains("hidden")) {
            triggerGlitchFor(cannon);
          }
        }

        function scheduleLogoGlitch(initialDelay = LOGO_GLITCH_INTERVAL) {
          clearTimeout(logoTimer);
          const jitter = Math.random() * LOGO_GLITCH_JITTER;
          const delay = Math.max(0, initialDelay) + jitter;
          logoTimer = setTimeout(() => {
            triggerLogoGlitch();
            scheduleLogoGlitch(LOGO_GLITCH_INTERVAL);
          }, delay);
        }

        function resolveMouthOffset(element) {
          if (!element) return CANNON_MOUTH_OFFSETS[ACTIVE_CANNON_CORNER];
          for (const cls of ALL_CANNON_CORNER_CLASSES) {
            if (element.classList.contains(cls) && CANNON_MOUTH_OFFSETS[cls]) {
              return CANNON_MOUTH_OFFSETS[cls];
            }
          }
          return CANNON_MOUTH_OFFSETS[ACTIVE_CANNON_CORNER];
        }

        function getCannonMouthPosition(element = cannon, areaRect) {
          if (!element) {
            return { pageX: 0, pageY: 0, areaX: 0, areaY: 0 };
          }
          if (!areaRect && element === cannon) {
            areaRect = gameArea.getBoundingClientRect();
          }
          const rect = element.getBoundingClientRect();
          if (!rect.width || !rect.height) {
            const fallback = { pageX: rect.left, pageY: rect.top };
            if (areaRect) {
              fallback.areaX = fallback.pageX - areaRect.left;
              fallback.areaY = fallback.pageY - areaRect.top;
            }
            return fallback;
          }
          const { x: offsetX, y: offsetY } = resolveMouthOffset(element);
          const pageX = rect.left + rect.width * offsetX;
          const pageY = rect.top + rect.height * offsetY;
          const position = { pageX, pageY };
          if (areaRect) {
            position.areaX = pageX - areaRect.left;
            position.areaY = pageY - areaRect.top;
          }
          return position;
        }

        function aimCannonAtRect(element, targetRect) {
          if (!element || !targetRect) return;
          const { pageX, pageY } = getCannonMouthPosition(element);
          const centerX = targetRect.left + targetRect.width / 2;
          const centerY = targetRect.top + targetRect.height / 2;
          const angle = Math.atan2(centerY - pageY, centerX - pageX);
          element.style.setProperty("--cannon-rotation", `${angle}rad`);
        }

        function pointCannonAtCenter() {
          if (gameArea.classList.contains("hidden")) return;
          const areaRect = gameArea.getBoundingClientRect();
          if (!areaRect.width || !areaRect.height) return;
          aimCannonAtRect(cannon, areaRect);
        }

        function pointAttractCannonIdle() {
          if (!attractCannon) return;
          attractCannon.style.setProperty(
            "--cannon-rotation",
            `${ATTRACT_CANNON_IDLE_ANGLE}rad`,
          );
        }

        function applyCannonCorner(element) {
          if (!element) return;
          element.classList.remove(...ALL_CANNON_CORNER_CLASSES);
          element.classList.add(ACTIVE_CANNON_CORNER);
        }

        function resetCannonPosition() {
          applyCannonCorner(cannon);
          requestAnimationFrame(pointCannonAtCenter);
        }

        window.addEventListener("resize", () => {
          requestAnimationFrame(() => {
            pointAttractCannonIdle();
            pointCannonAtCenter();
          });
        });

        function spawnStain(x, y) {
          const s = document.createElement("img");
          s.src = randomImage();
          s.className = "stain";
          s.dataset.stain = "true";
          const rect = gameArea.getBoundingClientRect();
          const topMargin = computeTopMargin(rect);
          const spawnW = Math.max(0, rect.width - STAIN_SIZE);
          const spawnH = Math.max(
            0,
            rect.height - STAIN_SIZE - topMargin - BOTTOM_MARGIN,
          );
          if (x === undefined) {
            x = Math.random() * spawnW;
          }
          if (y === undefined) {
            y = Math.random() * spawnH + topMargin;
          }
          s.style.left = x + "px";
          s.style.top = y + "px";
          s.style.width = STAIN_SIZE + "px";
          s.style.height = STAIN_SIZE + "px";
          s.style.transform = `rotate(${Math.random() * 360}deg)`;
          const remove = () => {
            if (!s.isConnected) return;
            s.removeEventListener("pointerdown", remove);
            s.remove();
            s.__removeStain = null;
            remaining = Math.max(0, (remaining || 0) - 1);
            updateProgressDisplay();
            if (remaining === 0 && seconds > 0) win();
          };
          s.addEventListener("pointerdown", remove);
          s.__removeStain = remove;
          gameArea.appendChild(s);
          remaining = (remaining || 0) + 1;
          total = (total || 0) + 1;
          updateProgressDisplay();
          return s;
        }

        function animateProjectile(el, x0, y0, x1, y1) {
          const duration = 800;
          const arc = 150;
          const start = performance.now();
          function frame(now) {
            const t = Math.min((now - start) / duration, 1);
            const x = x0 + (x1 - x0) * t;
            const y = y0 + (y1 - y0) * t - arc * Math.sin(Math.PI * t);
            el.style.left = x + "px";
            el.style.top = y + "px";
            if (t < 1) {
              requestAnimationFrame(frame);
            } else {
              el.style.left = x1 + "px";
              el.style.top = y1 + "px";
            }
          }
          requestAnimationFrame(frame);
        }

        function fireCannon() {
          const area = gameArea.getBoundingClientRect();
          const { areaX: mouthX, areaY: mouthY } = getCannonMouthPosition(
            cannon,
            area,
          );
          const topMargin = computeTopMargin(area);
          const spawnW = Math.max(0, area.width - STAIN_SIZE);
          const spawnH = Math.max(
            0,
            area.height - STAIN_SIZE - topMargin - BOTTOM_MARGIN,
          );
          const targetX = Math.random() * spawnW;
          const targetY = Math.random() * spawnH + topMargin;
          const angle = Math.atan2(targetY - mouthY, targetX - mouthX);
          const offset = 30;
          const startX = mouthX + Math.cos(angle) * offset;
          const startY = mouthY + Math.sin(angle) * offset;
          const s = spawnStain(startX, startY);
          animateProjectile(s, startX, startY, targetX, targetY);
          pointCannonAtCenter();
        }

        function startRound() {
          begin();
          if (typeof google !== "undefined") {
            google.script.run
              .withSuccessHandler((s) => {
                winStreak = s;
                updateStreakBadge();
              })
              .withFailureHandler(() => {})
              .refreshStreakTimer();
          }
        }

        function requestStartRound() {
          if (isRoundActive) return;
          startRound();
        }

        function begin() {
          if (pendingHighScore !== null) {
            skipHighScoreName();
          } else {
            hideHighScoreNameEntry();
          }
          clearTimeout(resetTimer);
          applyDifficulty();
          isRoundActive = true;
          clearTimeout(fireResumeTimer);
          hidePowerupToast();
          clearPowerUps();
          startScreen.classList.add("hidden");
          clearTimeout(bubbleTimer);
          startScreen.querySelectorAll(".bubble").forEach((b) => b.remove());
          gameArea.classList.remove("hidden");
          resetCannonPosition();
          triggerLogoGlitch();
          scheduleLogoGlitch(0);
          gameArea.querySelectorAll(".stain").forEach((s) => s.remove());
          if (!gameArea.contains(timerEl)) gameArea.appendChild(timerEl);
          remaining = 0;
          total = 0;
          resultShown = false;
          updateHighScoreDisplay();
          highScoreEl.classList.remove("hidden");
          updateStreakBadge();
          updateProgressDisplay();
          for (let i = 0; i < STAIN_START; i++) spawnStain();
          seconds = GAME_TIME;
          timerEl.textContent = seconds;
          startTime = now();
          clearInterval(countdown);
          countdown = setInterval(() => {
            seconds--;
            timerEl.textContent = seconds;
            if (seconds <= 0) {
              clearInterval(countdown);
              clearInterval(fireInterval);
              lose();
            }
          }, 1000);
          startFireLoop(FIRE_RATE);
          schedulePowerUp();
        }

        function win() {
          clearInterval(countdown);
          clearInterval(fireInterval);
          // Double-check no stain elements remain before allowing a win
          const stainsLeft = gameArea.querySelectorAll(".stain").length;
          showResult(stainsLeft === 0);
        }

        function lose() {
          showResult(false);
        }

        function setResultMessage(title, body, status) {
          if (!resultText) return;
          resultText.replaceChildren();
          const heading = document.createElement("div");
          const toneClass =
            status === "win" ? "text-emerald-500" : "text-rose-500";
          heading.className = `text-6xl font-black drop-shadow-sm ${toneClass}`;
          heading.textContent = title;
          const bodyEl = document.createElement("div");
          bodyEl.className = "text-2xl font-semibold text-stone-700";
          bodyEl.textContent = body;
          resultText.appendChild(heading);
          resultText.appendChild(bodyEl);
        }

        function showResult(success) {
          if (resultShown) return;
          resultShown = true;
          isRoundActive = false;
          clearTimeout(fireResumeTimer);
          clearPowerUps();
          hidePowerupToast();
          gameArea.classList.add("hidden");
          resultScreen.classList.remove("hidden");
          qrWrap.innerHTML = "";
          qrWrap.className = "p-4 bg-stone-100 rounded-2xl shadow-inner";
          const payload = {
            score: total - remaining,
            missed: remaining,
            duration: (now() - startTime) / 1000,
            device: DEVICE,
          };
          const tip =
            cleaningTips[Math.floor(Math.random() * cleaningTips.length)];
          if (success) {
            payload.missed = 0;
            payload.score = total;
            const level = winStreak + 1;
            const prize = pickPrize(level);
            payload.prizeTier = prize.tier;
            let code = "";
            const winMessage =
              prize.tier === "Common"
                ? "Great job! Enjoy this cleaning tip 🌱"
                : `Great job! You won ${prize.reward}!`;
            setResultMessage("You Won!", winMessage, "win");
            qrWrap.className =
              "p-6 bg-emerald-50 rounded-2xl shadow-md flex flex-col items-center gap-4 max-w-lg";
            if (prize.tier !== "Common") {
              const prizeWrap = document.createElement("div");
              prizeWrap.className = "relative inline-block";
              const staticEl = document.createElement("div");
              staticEl.className =
                "text-5xl font-extrabold text-yellow-400 text-center drop-shadow-lg";
              staticEl.textContent = prize.reward;
              const flashEl = document.createElement("div");
              flashEl.className =
                "text-5xl font-extrabold text-yellow-400 flash text-center drop-shadow-lg absolute inset-0";
              flashEl.textContent = prize.reward;
              prizeWrap.appendChild(staticEl);
              prizeWrap.appendChild(flashEl);
              qrWrap.appendChild(prizeWrap);
              const noteEl = document.createElement("div");
              noteEl.className = "text-sm text-stone-600 text-center";
              noteEl.textContent =
                "Take a Photo of Credit & Show to CSR & also brag on social media about your win.";
              qrWrap.appendChild(noteEl);
              if (prize.tier === "Epic") {
                const capEl = document.createElement("div");
                capEl.className = "text-xs text-stone-500 text-center";
                capEl.textContent = "1/day cap, manager approval";
                qrWrap.appendChild(capEl);
              }
              const shareEl = document.createElement("div");
              shareEl.className = "text-sm text-stone-600 text-center";
              shareEl.innerHTML =
                'Share with your friends your Winnings & High Scores to social. Tag us @dublincleaners on Facebook and/or Instagram.<span class="inline-flex items-center gap-1 ml-1"><img src="https://cdn.simpleicons.org/facebook/1877F2" alt="Facebook logo" class="h-4 w-4" /><img src="https://cdn.simpleicons.org/instagram/E4405F" alt="Instagram logo" class="h-4 w-4" /></span>';
              qrWrap.appendChild(shareEl);
              code = genCode();
              payload.prizeCode = code;
              const codeEl = document.createElement("div");
              codeEl.className = "font-mono text-lg text-center";
              codeEl.textContent = `Code: ${code}`;
              qrWrap.appendChild(codeEl);
              const disclaimerEl = document.createElement("div");
              disclaimerEl.className = "text-xs text-stone-500 text-center";
              disclaimerEl.innerHTML =
                "Coupon cannot be combined with any other coupons or offers. Limit one coupon per visit per customer. No cash value. Valid only at participating locations. Other restrictions may apply.";
              qrWrap.appendChild(disclaimerEl);
            }
            const tipDiv = document.createElement("div");
            tipDiv.className = "text-xl text-stone-700 whitespace-pre-line";
            tipDiv.innerHTML = tip;
            qrWrap.appendChild(tipDiv);
            confetti();
            if (typeof google !== "undefined") {
              google.script.run
                .withFailureHandler(() => {})
                .logGame(JSON.stringify(payload));
              google.script.run
                .withSuccessHandler((r) => {
                  winStreak = r.winStreak;
                  updateStreakBadge();
                })
                .handleWin();
            } else {
              winStreak = 0;
              updateStreakBadge();
            }
          } else {
            setResultMessage(
              "You Lost!",
              "Thanks for playing! Tap Play Again to try again.",
              "lose",
            );
            qrWrap.className =
              "p-6 bg-emerald-50 rounded-2xl shadow-md flex flex-col items-center gap-4 max-w-lg";
            const tipDiv = document.createElement("div");
            tipDiv.className = "text-xl text-stone-700 whitespace-pre-line";
            tipDiv.innerHTML = tip;
            qrWrap.appendChild(tipDiv);
            if (typeof google !== "undefined") {
              google.script.run
                .withFailureHandler(() => {})
                .logGame(JSON.stringify(payload));
              google.script.run
                .withSuccessHandler((r) => {
                  winStreak = r.winStreak;
                  updateStreakBadge();
                })
                .withFailureHandler(() => {})
                .resetStreak();
            }
            winStreak = 0;
            updateStreakBadge();
          }
          if (isNewHighScore(payload.score)) {
            const hsWrap = document.createElement("div");
            hsWrap.className = "relative inline-block";
            const staticEl = document.createElement("div");
            staticEl.className =
              "text-6xl font-extrabold text-rose-500 text-center drop-shadow-lg";
            staticEl.textContent = "New Su-Stained High Score!";
            const flashEl = document.createElement("div");
            flashEl.className =
              "text-6xl font-extrabold text-rose-500 flash text-center drop-shadow-lg absolute inset-0";
            flashEl.textContent = "New Su-Stained High Score!";
            hsWrap.appendChild(staticEl);
            hsWrap.appendChild(flashEl);
            qrWrap.prepend(hsWrap);
            showHighScoreNameEntry(payload.score);
          } else {
            updateHighScoreDisplay();
          }
          clearTimeout(resetTimer);
          resetTimer = setTimeout(() => {
            if (!resultScreen.classList.contains("hidden")) reset();
          }, RESET_DELAY);
        }

        function confetti() {
          if (window.confetti) {
            window.confetti({
              particleCount: 160,
              spread: 90,
              origin: { y: 0.6 },
              zIndex: 1,
            });
          }
        }

        function reset() {
          clearTimeout(resetTimer);
          isRoundActive = false;
          clearTimeout(fireResumeTimer);
          clearPowerUps();
          hidePowerupToast();
          resultScreen.classList.add("hidden");
          startScreen.classList.remove("hidden");
          resultShown = false;
          applyCannonCorner(attractCannon);
          requestAnimationFrame(pointAttractCannonIdle);
          if (pendingHighScore !== null) {
            skipHighScoreName();
          } else {
            hideHighScoreNameEntry();
            updateHighScoreDisplay();
          }
          highScoreEl.classList.remove("hidden");
          triggerLogoGlitch();
          scheduleLogoGlitch();
          scheduleBubble();
        }

        highScoreKeyboard.addEventListener("pointerdown", (event) => {
          const keyBtn = event.target.closest("button[data-key]");
          if (!keyBtn) return;
          event.preventDefault();
          handleVirtualKeyPress(keyBtn.dataset.key);
        });

        saveHighScoreBtn.addEventListener("pointerdown", (event) => {
          event.preventDefault();
          finalizeHighScore(highScoreNameInput.value);
        });

        skipHighScoreBtn.addEventListener("pointerdown", (event) => {
          event.preventDefault();
          skipHighScoreName();
        });

        updateHighScoreDisplay();
        highScoreEl.classList.remove("hidden");
        applyCannonCorner(attractCannon);
        applyCannonCorner(cannon);
        requestAnimationFrame(() => {
          pointAttractCannonIdle();
          pointCannonAtCenter();
        });

        playBtn.addEventListener("pointerdown", (event) => {
          event.preventDefault();
          requestStartRound();
        });
        if (playBubble) {
          playBubble.addEventListener("pointerdown", (event) => {
            if (event.target.closest("button")) return;
            event.preventDefault();
            requestStartRound();
          });
        }
        document
          .getElementById("restartBtn")
          .addEventListener("pointerdown", () => {
            resultScreen.classList.add("hidden");
            startRound();
          });

        triggerLogoGlitch();
        scheduleLogoGlitch();
        scheduleBubble();
      })();
    </script>
  </body>
</html>
